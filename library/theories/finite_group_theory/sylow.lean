import theories.number_theory.pinat
import data algebra.group .subgroup .finsubg theories.number_theory.pinat .cyclic .perm .action 
import .extra_action .quotient .extra_finsubg data.finset.extra_finset
import .newpgroup

open nat finset fintype group_theory subtype

namespace group_theory

variables {G : Type} [ambientG : group G] [finG : fintype G] [deceqG : decidable_eq G]
include ambientG deceqG finG

section SylowTheorem

parameter {p : nat}
variable A : finset G
variable [HAfG : is_finsubg A]

-- for this definition to be interesting, we need to be able to talk about the group generated by H : finset G
-- this may be done later but is not urgent
-- definition maxGroup [reducible] (P : subgroup G → Prop) [HdecP : ∀ B, decidable (P B)] (H : finset G) : Prop :=
--   maxSet (λ (B : finset) ,

-- pose maxp A P := [max P | p.-subgroup(A) P];
definition maxp [class] (P : finset G) : Prop := maxSet (λ (B : finset G), pi_subgroup (pred_p p) B A ∧ is_finsubg_prop G B) P

attribute maxp [reducible]

-- lemma maxp_refl (P : finset G) : maxp A P → pi_subgroup (pred_p p) P A ∧ is_finsubg_prop G P :=
--   assume (Hmaxp : maxp A P),
--   maxsetp Hmaxp

-- TODO : extend to maxgroup (see fingroup.v)

definition maxp_is_finsubg [instance] (P : finset G) [Hmaxp : maxp A P] : is_finsubg P
:= have H : is_finsubg_prop G P, from and.right (maxsetp Hmaxp), is_finsubg_is_finsubg_prop H

definition decidable_maxp [instance] (P : finset G) : decidable (maxp A P) :=
decidable_maxset (λ B, pi_subgroup (pred_p p) B A ∧ is_finsubg_prop G B) P

-- reveal decidable_maxp
-- pose S := [set P | maxp G P].

definition S := { P : subgroup G | maxp A (elt_of P) }

-- S A is a fintype because it is a subtype of a subtype of a fintype. There seem to be no instances of this yet
definition finTSA [instance] : fintype (S A) := sorry


-- definition S := subtype (maxp A)

-- definition f : G → S → S := sorry

abbreviation normalizer_in [reducible] (S T : finset G) : finset G := T ∩ normalizer S

-- SmaxN P Q: Q \in S -> Q \subset 'N(P) -> maxp 'N_G(P) Q.
-- reminder: 'N(P) = the normalizer of P, 'N_G(P) = the normalizer of P in G
lemma SmaxN (P Q : finset G) : maxp A Q → Q ⊆ normalizer P → maxp (normalizer_in P A) Q :=
  assume (HmaxP : maxp A Q) HQnormP,
  iff.elim_right (maxSet_iff)
  (take B HQB,
  have H : _, from iff.elim_left (maxSet_iff) HmaxP B HQB,
  iff.intro
  (assume H1,
  begin
  apply (iff.elim_left H),
  apply and.intro,
  apply pi_subgroup_trans (and.left H1),
  exact (finset_inter_subset_left),
  exact (and.right H1)
  end)
  (assume Heq,
  begin
  have pi_subgroup (pred_p p) B A ∧ is_finsubg_prop G B, from iff.elim_right H Heq,
  apply and.intro,
  have Hsub : B ⊆ (A ∩ (normalizer P)),
  from (subset_inter (and.left (and.left this)) ((eq.symm Heq) ▸ HQnormP)),
  apply (pi_subgroup_sub (and.left this) Hsub),
  exact finset_inter_subset_left,
  exact and.right this
  end))


-- !!!!!!!! strange : Lean refuses to acknowledge the existence of is_normal_in from group_theory
-- Definition normal A B := (A \subset B) && (B \subset normaliser A).
-- definition is_normal_in (B C : finset G) : Prop := B ⊆ C ∧ C ⊆ (normalizer B)

-- lemma normSelf (A : finset G) : A ⊆ (normalizer A) :=
--   subset_normalizer

include HAfG

-- have nrmG P: P \subset G -> P <| 'N_G(P).
lemma nrmG (P : finset G) [HfGP : is_finsubg P] : P ⊆ A → is_normal_in A P (normalizer_in P A) :=
  assume sPA,
  and.intro
  (subset_inter sPA (subset_normalizer))
  (subset.trans sPA (subset_normalizer))

omit HAfG

-- (in pgroup.v) Lemma normal_max_pgroup_Hall G H :
--   [max H | pi.-subgroup(G) H] -> H <| G -> pi.-Hall(G) H.
-- let us do a less general version for starters
lemma normal_max_pgroup_Hall (B C : finset G) [HC : is_finsubg C] :
  maxp C B → is_normal_in A B C → pHall (pred_p p) B C :=
  assume HmaxB Hnormal,
  have toto : is_finsubg B, from _,
  have HB : (pi_subgroup (pred_p p) B C) ∧ is_finsubg_prop G B, from maxsetp HmaxB,
  and.intro (and.left Hnormal)
  (and.intro (and.right (and.left HB))
  (have toto : _, from and.right (and.left HB),
  have Hindex : index C B = (card _) , from _,
   _ -- here we need an argument explaining that if p divides [C : B],
    -- p = 1
  )
  )

-- have sylS P: P \in S -> p.-Sylow('N_G(P)) P.
lemma sylS (P : finset G) : maxp A P → is_sylow p P (normalizer_in P A) :=
  assume HmaxP,
  sorry

local attribute perm.f [coercion]

check λ g, action_by_conj_on_finsets g
print subtype.tag

definition pre_conjG (g : G) (s : (S A)) : finset G := (action_by_conj_on_finsets g (elt_of (elt_of s)))

lemma pre_conjG_in_S (g : G) (s : S A) : maxp A (pre_conjG A g s) :=
   have HmaxS : maxp A (elt_of (elt_of s)), from has_property s,
   begin
     apply (iff.elim_right maxSet_iff),
     intro B HsB,
     apply iff.intro,
     apply sorry,
     apply sorry
   end
 -- (λ (B : finset G), pi_subgroup (pred_p p) B A ∧ is_finsubg_prop G B) A
   -- (pre_conjG A g s)

definition conjG_hom (g : G) (s : S A) : _ := tag (pre_conjG A g s) (pre_conjG_in_S A g s)

-- definition conjG (g : G) : perm (S A) := perm.mk (λ s, action_by_conj_on_finsets g s) (action_by_conj_on_finsets_inj)

-- -- have{SmaxN} defCS P: P \in S -> 'Fix_(S |'JG)(P) = [set P].
-- lemma defCS (P : finset G) : maxp A P → fixed_points conjG (S A) = insert P empty := sorry

end SylowTheorem

end group_theory
